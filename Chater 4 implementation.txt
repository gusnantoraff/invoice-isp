CHAPTER IV IMPLEMENTATION

4.1 Implementation of CRUD Data Collection of Fiber Optics Topology and Inventory Information

The implementation of the Fiber Optics Topology and Inventory Information system was developed using a modern web application architecture with Laravel PHP framework for the backend API and React TypeScript for the frontend client application. This system provides comprehensive CRUD (Create, Read, Update, Delete) operations for managing fiber optic infrastructure components including locations, ODCs (Optical Distribution Cabinets), cables, tubes, cores, ODPs (Optical Distribution Points), and FTTH clients.

4.1.1 Fiber Optics Backend Implementation

The backend implementation was built using Laravel 10 framework with a RESTful API architecture. The system consists of seven main entities that form a hierarchical structure representing the fiber optic network topology.

4.1.1.1 Database Schema Design

The database schema was designed with proper relationships and constraints to maintain data integrity. Each table implements soft deletes for data preservation and includes status management for active/archived states.

**FoLokasi (Locations) Table:**
```php
Schema::create('fo_lokasis', function (Blueprint $table) {
    $table->id();
    $table->string('nama_lokasi');
    $table->string('deskripsi')->nullable();
    $table->decimal('latitude', 10, 7);
    $table->decimal('longitude', 10, 7);
    $table->enum('status', ['active', 'archived'])->default('active');
    $table->softDeletes();
    $table->timestamps();
});
```

**FoOdc (Optical Distribution Cabinets) Table:**
```php
Schema::create('fo_odcs', function (Blueprint $table) {
    $table->id();
    $table->foreignId('lokasi_id')->constrained('fo_lokasis')->cascadeOnDelete()->cascadeOnUpdate();
    $table->string('nama_odc');
    $table->enum('tipe_splitter', ['1:2', '1:4', '1:8', '1:16', '1:32', '1:64', '1:128']);
    $table->enum('status', ['active', 'archived'])->default('active');
    $table->softDeletes();
    $table->timestamps();
});
```

**FoKabelOdc (ODC Cables) Table with Automatic Core Calculation:**
```php
Schema::create('fo_kabel_odcs', function (Blueprint $table) {
    $table->id();
    $table->foreignId('odc_id')->constrained('fo_odcs')->cascadeOnDelete()->cascadeOnUpdate();
    $table->string('nama_kabel');
    $table->enum('tipe_kabel', ['singlecore', 'multicore']);
    $table->decimal('panjang_kabel', 8, 2);
    $table->integer('jumlah_tube');
    $table->integer('jumlah_core_in_tube');
    $table->integer('jumlah_total_core'); // Auto-calculated
    $table->enum('status', ['active', 'archived'])->default('active');
    $table->softDeletes();
    $table->timestamps();
});
```

The automatic calculation of total cores is implemented in the model using Laravel's model events:
```php
protected static function boot()
{
    parent::boot();

    // Before every save (create or update), recalc jumlah_total_core
    static::saving(function (FoKabelOdc $model) {
        $model->jumlah_total_core = $model->jumlah_tube * $model->jumlah_core_in_tube;
    });
}
```

4.1.1.2 Model Relationships and Eloquent ORM

The Laravel Eloquent models were implemented with proper relationships to maintain data integrity and enable efficient querying:

```php
// app/Models/FoLokasi.php
class FoLokasi extends Model
{
    use SoftDeletes;

    protected $fillable = [
        'nama_lokasi', 'deskripsi', 'latitude', 'longitude', 'status'
    ];

    protected $casts = [
        'latitude' => 'float',
        'longitude' => 'float',
        'status' => 'string',
        'deleted_at' => 'datetime',
    ];

    public function odcs()
    {
        return $this->hasMany(FoOdc::class, 'lokasi_id');
    }

    public function odps()
    {
        return $this->hasMany(FoOdp::class, 'lokasi_id');
    }

    public function clientFtths()
    {
        return $this->hasMany(FoClientFtth::class, 'lokasi_id');
    }
}
```

4.1.1.3 API Controller Implementation

Six RESTful controllers were implemented with comprehensive CRUD operations. Each controller follows Laravel best practices with proper validation, error handling, and response formatting.

**FoLokasiController - Index Method with Advanced Filtering:**
```php
public function index(Request $request)
{
    // Parse status parameter for filtering
    $statusParam = $request->query('status', 'active');
    $requested = collect(explode(',', $statusParam))
        ->map(fn($s) => trim(strtolower($s)))
        ->filter()
        ->unique()
        ->values()
        ->all();

    $validStatuses = ['active', 'archived', 'deleted'];
    $statuses = array_values(array_intersect($requested, $validStatuses));
    if (empty($statuses)) {
        $statuses = ['active'];
    }

    // Base query with trashed support
    $query = FoLokasi::withTrashed();

    // Filter by status with complex logic
    $query->where(function ($q) use ($statuses) {
        if (in_array('deleted', $statuses, true)) {
            $q->orWhereNotNull('deleted_at');
        }

        $nonDeleted = array_values(array_intersect($statuses, ['active', 'archived']));
        if (!empty($nonDeleted)) {
            $q->orWhere(function ($sub) use ($nonDeleted) {
                $sub->whereNull('deleted_at')
                    ->whereIn('status', $nonDeleted);
            });
        }
    });

    // Text filtering
    if ($request->filled('filter')) {
        $term = $request->query('filter');
        $query->where(function ($q) use ($term) {
            $q->where('nama_lokasi', 'LIKE', "%{$term}%")
                ->orWhere('deskripsi', 'LIKE', "%{$term}%");
        });
    }

    // Sorting with validation
    if ($request->filled('sort')) {
        [$column, $dir] = array_pad(explode('|', $request->query('sort')), 2, null);
        $dir = (strtolower($dir) === 'dsc') ? 'desc' : 'asc';

        $allowedSorts = ['id', 'nama_lokasi', 'created_at', 'updated_at', 'status'];
        if (in_array($column, $allowedSorts, true)) {
            $query->orderBy($column, $dir);
        }
    } else {
        $query->orderBy('id', 'desc');
    }

    // Pagination with relationship loading
    $perPage = (int) $request->query('per_page', 15);
    if ($perPage <= 0) $perPage = 15;

    $paginator = $query
        ->with(['odcs', 'odps', 'clientFtths'])
        ->paginate($perPage)
        ->appends($request->only(['filter', 'sort', 'per_page', 'status']));

    // Transform data for consistent response
    $data = array_map(function ($l) {
        return [
            'id' => $l->id,
            'nama_lokasi' => $l->nama_lokasi,
            'deskripsi' => $l->deskripsi,
            'latitude' => $l->latitude,
            'longitude' => $l->longitude,
            'status' => $l->status,
            'odcs' => $l->odcs->map(fn($o) => [
                'id' => $o->id,
                'nama_odc' => $o->nama_odc,
            ])->toArray(),
            'odps' => $l->odps->map(fn($o) => [
                'id' => $o->id,
                'nama_odp' => $o->nama_odp,
            ])->toArray(),
            'clients' => $l->clientFtths->map(fn($c) => [
                'id' => $c->id,
                'nama_client' => $c->nama_client,
            ])->toArray(),
            'created_at' => $l->created_at->toDateTimeString(),
            'updated_at' => $l->updated_at->toDateTimeString(),
            'deleted_at' => $l->deleted_at?->toDateTimeString(),
        ];
    }, $paginator->items());

    return response()->json([
        'status' => 'success',
        'data' => $data,
        'meta' => [
            'current_page' => $paginator->currentPage(),
            'per_page' => $paginator->perPage(),
            'total' => $paginator->total(),
            'last_page' => $paginator->lastPage(),
            'from' => $paginator->firstItem(),
            'to' => $paginator->lastItem(),
        ],
    ], 200);
}
```

**Store Method with Validation:**
```php
public function store(Request $request)
{
    $data = $request->validate([
        'nama_lokasi' => 'required|string|max:255',
        'deskripsi' => 'nullable|string|max:255',
        'latitude' => 'required|numeric',
        'longitude' => 'required|numeric',
        'status' => 'sometimes|in:active,archived',
    ]);

    // Default to active if not provided
    if (!isset($data['status'])) {
        $data['status'] = 'active';
    }

    $lokasi = FoLokasi::create($data);

    return response()->json([
        'status' => 'success',
        'data' => [
            'id' => $lokasi->id,
            'nama_lokasi' => $lokasi->nama_lokasi,
            'deskripsi' => $lokasi->deskripsi,
            'latitude' => $lokasi->latitude,
            'longitude' => $lokasi->longitude,
            'status' => $lokasi->status,
            'created_at' => $lokasi->created_at->toDateTimeString(),
            'updated_at' => $lokasi->updated_at->toDateTimeString(),
        ],
        'message' => 'Lokasi created.',
    ], 201);
}
```

**Bulk Operations Implementation:**
```php
public function bulk(Request $request)
{
    $data = $request->validate([
        'action' => 'required|in:archive,delete,restore',
        'ids' => 'required|array|min:1',
        'ids.*' => 'integer|distinct',
    ]);

    $ids = $data['ids'];
    $action = $data['action'];

    switch ($action) {
        case 'archive':
            $this->model::withTrashed()
                ->whereIn('id', $ids)
                ->update(['status' => 'archived']);
            $message = 'Items archived.';
            break;

        case 'delete':
            $this->model::whereIn('id', $ids)->delete();
            $message = 'Items soft‐deleted.';
            break;

        case 'restore':
            $this->model::onlyTrashed()
                ->whereIn('id', $ids)
                ->restore();
            $this->model::whereIn('id', $ids)
                ->update(['status' => 'active']);
            $message = 'Items restored to active.';
            break;

        default:
            return response()->json([
                'status' => 'error',
                'message' => 'Invalid action.',
            ], 422);
    }

    return response()->json([
        'status' => 'success',
        'message' => $message,
    ], 200);
}
```

4.1.1.4 API Route Configuration

The API routes were configured with proper middleware and RESTful patterns:

```php
Route::group(['middleware' => ['throttle:api', 'api_db', 'token_auth', 'locale'], 'prefix' => 'api/v1', 'as' => 'api.'], function () {

    // FoLokasi Routes
    Route::get('/fo-lokasis', [FoLokasiController::class, 'index']);
    Route::post('/fo-lokasis', [FoLokasiController::class, 'store']);
    Route::get('/fo-lokasis/{id}', [FoLokasiController::class, 'show']);
    Route::put('/fo-lokasis/{id}', [FoLokasiController::class, 'update']);
    Route::patch('/fo-lokasis/{id}', [FoLokasiController::class, 'update']);
    Route::delete('/fo-lokasis/{id}', [FoLokasiController::class, 'destroy']);
    Route::patch('/fo-lokasis/{id}/archive', [FoLokasiController::class, 'archive']);
    Route::patch('/fo-lokasis/{id}/unarchive', [FoLokasiController::class, 'unarchive']);
    Route::patch('/fo-lokasis/{id}/restore', [FoLokasiController::class, 'restore']);
    Route::post('/fo-lokasis/bulk', [FoLokasiController::class, 'bulk']);

    // Similar patterns for all other entities...
    Route::get('/fo-odcs', [FoOdcController::class, 'index']);
    Route::post('/fo-odcs', [FoOdcController::class, 'store']);
    // ... additional routes for each entity
});
```

4.1.1.5 Advanced Validation and Business Logic

Complex validation rules were implemented for maintaining data integrity:

```php
// FoOdpController - Complex validation for unique core assignment
public function store(Request $request)
{
    $data = $request->validate([
        'lokasi_id' => 'required|exists:fo_lokasis,id',
        'kabel_core_odc_id' => [
            'required',
            'exists:fo_kabel_core_odcs,id',
            Rule::unique('fo_odps')->where(function ($query) {
                return $query->whereNull('deleted_at');
            })
        ],
        'nama_odp' => 'required|string|max:255',
        'status' => 'sometimes|in:active,archived',
    ]);

    // Check if core is already assigned to another ODP
    $existingOdp = FoOdp::where('kabel_core_odc_id', $data['kabel_core_odc_id'])
        ->whereNull('deleted_at')
        ->first();

    if ($existingOdp) {
        return response()->json([
            'status' => 'error',
            'message' => 'This core is already assigned to ODP: ' . $existingOdp->nama_odp,
        ], 422);
    }

    if (!isset($data['status'])) {
        $data['status'] = 'active';
    }

    $odp = FoOdp::create($data);
    $odp->load(['lokasi', 'kabelCoreOdc.kabelTubeOdc.kabelOdc.odc.lokasi']);

    return response()->json([
        'status' => 'success',
        'data' => $this->transformOdpData($odp),
        'message' => 'ODP created successfully.',
    ], 201);
}
```

4.1.2 Fiber Optics Frontend Implementation

The frontend implementation was developed using React 18 with TypeScript, providing a modern, responsive user interface for managing the fiber optics infrastructure.

4.1.2.1 Application Architecture and Route Configuration

The frontend follows a modular architecture with comprehensive routing:

```typescript
// client/src/common/routes.tsx
import { foLokasiRoutes } from '$app/pages/fo-lokasis/routes';
import { foOdcRoutes } from '$app/pages/fo-odcs/routes';
import { foKabelOdcRoutes } from '$app/pages/fo-kabel-odcs/routes';
import { foKabelTubeOdcRoutes } from '$app/pages/fo-kabel-tube-odcs/routes';
import { foKabelCoreOdcRoutes } from '$app/pages/fo-kabel-core-odcs/routes';
import { foOdpRoutes } from '$app/pages/fo-odps/routes';
import { foClientFtthRoutes } from '$app/pages/fo-client-ftths/routes';

export const routes = (
    <Routes>
        <Route path="/" element={<Index />} />
        {authenticationRoutes}
        <Route element={<PrivateRoute />}>
            <Route path="/dashboard" element={<Dashboard />} />
            {foLokasiRoutes}
            {foOdcRoutes}
            {foKabelOdcRoutes}
            {foKabelTubeOdcRoutes}
            {foKabelCoreOdcRoutes}
            {foOdpRoutes}
            {foClientFtthRoutes}
        </Route>
    </Routes>
);
```

4.1.2.2 Data Management with React Query

Custom hooks were implemented for each entity using React Query for efficient server state management:

```typescript
// client/src/common/queries/foLokasi.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { request } from '$app/common/helpers/request';
import { toast } from '$app/common/helpers/toast/toast';

export function useFoLokasiQuery(params?: {
    page?: number;
    per_page?: number;
    filter?: string;
    sort?: string;
    status?: string;
}) {
    return useQuery({
        queryKey: ['fo-lokasis', params],
        queryFn: () => request('GET', '/api/v1/fo-lokasis', { params }),
        staleTime: 5 * 60 * 1000, // 5 minutes
    });
}

export function useCreateFoLokasiMutation() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: (data: any) => request('POST', '/api/v1/fo-lokasis', data),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['fo-lokasis'] });
            toast.success('Lokasi created successfully');
        },
        onError: (error: any) => {
            toast.error(error?.data?.message || 'Failed to create lokasi');
        },
    });
}

export function useFoLokasiBulkAction() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: ({ action, ids }: { action: string; ids: string[] }) =>
            request('POST', '/api/v1/fo-lokasis/bulk', { action, ids }),
        onSuccess: (_, { action }) => {
            queryClient.invalidateQueries({ queryKey: ['fo-lokasis'] });
            toast.success(`Items ${action}d successfully`);
        },
        onError: (error: any) => {
            toast.error(error?.data?.message || 'Bulk operation failed');
        },
    });
}
```

4.1.2.3 Component Implementation with TypeScript

Comprehensive TypeScript interfaces and components were developed:

```typescript
// client/src/pages/fo-lokasis/common/hooks2.tsx
export interface FoLokasi {
    id: string;
    nama_lokasi: string;
    deskripsi?: string;
    latitude: number;
    longitude: number;
    status: 'active' | 'archived' | string;
    odcs: Array<{ id: string; nama_odc: string }>;
    odps: Array<{ id: string; nama_odp: string }>;
    clients: Array<{ id: string; nama_client: string }>;
    created_at: string;
    updated_at: string;
    deleted_at?: string | null;
}

export function useFoLokasiColumns() {
    const { t } = useTranslation();

    return useMemo(
        () => [
            {
                column: 'nama_lokasi',
                id: 'nama_lokasi',
                label: t('nama_lokasi'),
                format: (value: string) => value,
            },
            {
                column: 'deskripsi',
                id: 'deskripsi',
                label: t('deskripsi'),
                format: (value: string) => value || '-',
            },
            {
                column: 'latitude',
                id: 'latitude',
                label: t('latitude'),
                format: (value: number) => value.toFixed(6),
            },
            {
                column: 'longitude',
                id: 'longitude',
                label: t('longitude'),
                format: (value: number) => value.toFixed(6),
            },
            {
                column: 'status',
                id: 'status',
                label: t('status'),
                format: (value: string) => (
                    <Badge variant={value === 'active' ? 'success' : 'secondary'}>
                        {t(value)}
                    </Badge>
                ),
            },
            {
                column: 'created_at',
                id: 'created_at',
                label: t('created_at'),
                format: (value: string) => formatDate(value),
            },
        ],
        [t]
    );
}
```

4.1.2.4 Form Implementation with Validation

Advanced form components with real-time validation:

```typescript
// client/src/pages/fo-lokasis/common/components/CreateFoLokasi.tsx
interface FoLokasi {
    nama_lokasi: string;
    deskripsi?: string;
    latitude: number;
    longitude: number;
}

interface Props {
    foLokasi: FoLokasi;
    errors?: ValidationBag;
    setFoLokasi: Dispatch<SetStateAction<FoLokasi>>;
    setErrors: Dispatch<SetStateAction<ValidationBag | undefined>>;
}

export function CreateFoLokasi(props: Props) {
    const { foLokasi, errors, setFoLokasi, setErrors } = props;

    const handleChange = <K extends keyof FoLokasi>(
        field: K,
        value: FoLokasi[K]
    ) => {
        setFoLokasi((prev) => ({ ...prev, [field]: value }));
        setErrors(undefined);
    };

    return (
        <div className="grid grid-cols-12 gap-4">
            <div className="col-span-12 lg:col-span-6">
                <InputField
                    label={t('nama_lokasi')}
                    value={foLokasi.nama_lokasi}
                    onValueChange={(value) => handleChange('nama_lokasi', value)}
                    errorMessage={errors?.errors.nama_lokasi}
                    required
                />
            </div>

            <div className="col-span-12 lg:col-span-6">
                <InputField
                    label={t('deskripsi')}
                    value={foLokasi.deskripsi || ''}
                    onValueChange={(value) => handleChange('deskripsi', value)}
                    errorMessage={errors?.errors.deskripsi}
                />
            </div>

            <div className="col-span-12 lg:col-span-6">
                <InputField
                    label={t('latitude')}
                    type="number"
                    step="any"
                    value={foLokasi.latitude.toString()}
                    onValueChange={(value) => handleChange('latitude', parseFloat(value) || 0)}
                    errorMessage={errors?.errors.latitude}
                    required
                />
            </div>

            <div className="col-span-12 lg:col-span-6">
                <InputField
                    label={t('longitude')}
                    type="number"
                    step="any"
                    value={foLokasi.longitude.toString()}
                    onValueChange={(value) => handleChange('longitude', parseFloat(value) || 0)}
                    errorMessage={errors?.errors.longitude}
                    required
                />
            </div>
        </div>
    );
}
```

4.1.2.5 Index Component with Advanced Features

Data grid implementation with filtering, sorting, and bulk operations:

```typescript
// client/src/pages/fo-lokasis/index/FoLokasis.tsx
export default function FoLokasis() {
    const { t } = useTranslation();
    const [currentPage, setCurrentPage] = useState(1);
    const [perPage, setPerPage] = useState(15);
    const [filter, setFilter] = useState('');
    const [sort, setSort] = useState('');
    const [status, setStatus] = useState('active');
    const [selectedIds, setSelectedIds] = useState<string[]>([]);

    const { data, isLoading } = useFoLokasiQuery({
        page: currentPage,
        per_page: perPage,
        filter,
        sort,
        status,
    });

    const bulkAction = useFoLokasiBulkAction();

    const handleBulkAction = (action: 'archive' | 'delete' | 'restore') => {
        if (selectedIds.length === 0) {
            toast.error('Please select items to perform bulk action');
            return;
        }

        bulkAction.mutate({ action, ids: selectedIds });
        setSelectedIds([]);
    };

    const columns = useFoLokasiColumns();
    const actions = useFoLokasiActions();

    return (
        <Default
            title={t('fo_lokasis')}
            breadcrumbs={[
                { name: t('fo_lokasis'), href: '/fo-lokasis' },
            ]}
            topRight={
                <Link to="/fo-lokasis/create">
                    <Button>{t('new_fo_lokasi')}</Button>
                </Link>
            }
        >
            <DataTable
                resource="fo_lokasis"
                columns={columns}
                data={data?.data || []}
                isLoading={isLoading}
                pagination={{
                    currentPage,
                    setCurrentPage,
                    perPage,
                    setPerPage,
                    total: data?.meta?.total || 0,
                }}
                filters={{
                    filter,
                    setFilter,
                    status,
                    setStatus,
                }}
                sorting={{
                    sort,
                    setSort,
                }}
                bulkActions={{
                    selectedIds,
                    setSelectedIds,
                    actions: [
                        {
                            label: t('archive'),
                            onClick: () => handleBulkAction('archive'),
                        },
                        {
                            label: t('delete'),
                            onClick: () => handleBulkAction('delete'),
                        },
                        {
                            label: t('restore'),
                            onClick: () => handleBulkAction('restore'),
                        },
                    ],
                }}
                actions={actions}
            />
        </Default>
    );
}
```

4.1.2.6 Complex Form with Relationship Management

Advanced form implementation for entities with complex relationships:

```typescript
// client/src/pages/fo-odcs/common/components/CreateFoOdc.tsx
export interface FoOdcFormValues {
    create_new_lokasi: boolean;
    lokasi_id: string;
    lokasi_name: string;
    lokasi_deskripsi: string;
    lokasi_latitude: string;
    lokasi_longitude: string;
    nama_odc: string;
    tipe_splitter: string;
}

interface Props {
    values: FoOdcFormValues;
    setValues: React.Dispatch<React.SetStateAction<FoOdcFormValues>>;
    lokasis: LokasiOption[];
    errors?: ValidationBag;
}

export function CreateFoOdc({ values, setValues, lokasis, errors }: Props) {
    const { t } = useTranslation();

    const onChange = <K extends keyof FoOdcFormValues>(
        field: K,
        value: FoOdcFormValues[K]
    ) => setValues((v) => ({ ...v, [field]: value }));

    return (
        <div className="grid grid-cols-12 gap-4">
            <div className="col-span-12">
                <Checkbox
                    label={t('create_new_lokasi')}
                    checked={values.create_new_lokasi}
                    onValueChange={(value) => onChange('create_new_lokasi', value)}
                />
            </div>

            {values.create_new_lokasi ? (
                // New location form fields
                <>
                    <div className="col-span-12 lg:col-span-6">
                        <InputField
                            label={t('lokasi_name')}
                            value={values.lokasi_name}
                            onValueChange={(value) => onChange('lokasi_name', value)}
                            errorMessage={errors?.errors['lokasi.name']}
                            required
                        />
                    </div>
                    {/* Additional location fields */}
                </>
            ) : (
                // Existing location selection
                <div className="col-span-12 lg:col-span-6">
                    <SelectField
                        label={t('lokasi')}
                        value={values.lokasi_id}
                        onValueChange={(value) => onChange('lokasi_id', value)}
                        errorMessage={errors?.errors.lokasi_id}
                        required
                    >
                        <option value="">{t('select_lokasi')}</option>
                        {lokasis.map((lokasi) => (
                            <option key={lokasi.id} value={lokasi.id}>
                                {lokasi.nama_lokasi}
                            </option>
                        ))}
                    </SelectField>
                </div>
            )}

            <div className="col-span-12 lg:col-span-6">
                <InputField
                    label={t('nama_odc')}
                    value={values.nama_odc}
                    onValueChange={(value) => onChange('nama_odc', value)}
                    errorMessage={errors?.errors.nama_odc}
                    required
                />
            </div>

            <div className="col-span-12 lg:col-span-6">
                <SelectField
                    label={t('tipe_splitter')}
                    value={values.tipe_splitter}
                    onValueChange={(value) => onChange('tipe_splitter', value)}
                    errorMessage={errors?.errors.tipe_splitter}
                    required
                >
                    <option value="">{t('select_splitter')}</option>
                    <option value="1:2">1:2</option>
                    <option value="1:4">1:4</option>
                    <option value="1:8">1:8</option>
                    <option value="1:16">1:16</option>
                    <option value="1:32">1:32</option>
                    <option value="1:64">1:64</option>
                    <option value="1:128">1:128</option>
                </SelectField>
            </div>
        </div>
    );
}
```

4.1.2.7 Error Handling and User Feedback

Comprehensive error handling and user feedback mechanisms:

```typescript
// client/src/pages/fo-lokasis/create/Create.tsx
export default function Create() {
    const { t } = useTranslation();
    const navigate = useNavigate();

    const [foLokasi, setFoLokasi] = useState<FoLokasi>({
        nama_lokasi: '',
        deskripsi: '',
        latitude: 0,
        longitude: 0,
    });

    const [errors, setErrors] = useState<ValidationBag>();

    const createMutation = useCreateFoLokasiMutation();

    const handleSave = (event: FormEvent) => {
        event.preventDefault();

        if (!foLokasi.nama_lokasi.trim()) {
            setErrors({ errors: { nama_lokasi: [t('nama_lokasi_required')] } });
            return;
        }

        createMutation.mutate(foLokasi, {
            onSuccess: () => {
                navigate('/fo-lokasis');
            },
            onError: (error: any) => {
                if (error?.data?.errors) {
                    setErrors(error.data);
                }
            },
        });
    };

    return (
        <Default
            title={t('new_fo_lokasi')}
            breadcrumbs={[
                { name: t('fo_lokasis'), href: '/fo-lokasis' },
                { name: t('new_fo_lokasi'), href: '/fo-lokasis/create' },
            ]}
            onSaveClick={handleSave}
            disableSaveButton={createMutation.isPending}
        >
            <form onSubmit={handleSave}>
                <CreateFoLokasi
                    foLokasi={foLokasi}
                    errors={errors}
                    setFoLokasi={setFoLokasi}
                    setErrors={setErrors}
                />
            </form>
        </Default>
    );
}
```

4.1.2.8 Performance Optimization and Caching

The frontend implements several performance optimizations:

```typescript
// React Query configuration for optimal caching
const queryClient = new QueryClient({
    defaultOptions: {
        queries: {
            staleTime: 5 * 60 * 1000, // 5 minutes
            cacheTime: 10 * 60 * 1000, // 10 minutes
            retry: 3,
            retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
        },
        mutations: {
            retry: 1,
        },
    },
});

// Optimistic updates for better UX
export function useUpdateFoLokasiMutation() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: ({ id, data }: { id: string; data: any }) =>
            request('PUT', `/api/v1/fo-lokasis/${id}`, data),
        onMutate: async ({ id, data }) => {
            // Cancel outgoing refetches
            await queryClient.cancelQueries({ queryKey: ['fo-lokasis'] });

            // Snapshot previous value
            const previousLokasis = queryClient.getQueryData(['fo-lokasis']);

            // Optimistically update
            queryClient.setQueryData(['fo-lokasis'], (old: any) => ({
                ...old,
                data: old.data.map((lokasi: any) =>
                    lokasi.id === id ? { ...lokasi, ...data } : lokasi
                ),
            }));

            return { previousLokasis };
        },
        onError: (err, variables, context) => {
            // Rollback on error
            if (context?.previousLokasis) {
                queryClient.setQueryData(['fo-lokasis'], context.previousLokasis);
            }
        },
        onSettled: () => {
            // Always refetch after error or success
            queryClient.invalidateQueries({ queryKey: ['fo-lokasis'] });
        },
    });
}
```

The implementation provides a comprehensive, scalable, and user-friendly system for managing fiber optics infrastructure with proper data integrity, performance optimization, and security measures. The modular architecture allows for easy maintenance and future enhancements while providing a robust foundation for fiber optics network management. The combination of Laravel's robust backend capabilities with React's modern frontend features creates a powerful and efficient system for managing complex hierarchical data relationships in fiber optics infrastructure.

4.2 Implementation of FTTH Reports

The FTTH (Fiber to the Home) reporting system provides comprehensive analytics and insights into the fiber optics infrastructure. This section details the implementation of the reporting dashboard, data visualization components, and export functionality.

4.2.1 Report Architecture and Navigation

The reporting system implements a tabbed interface with multiple report types:

```typescript
// client/src/pages/fo-reports/routes.tsx
export const foReportRoutes = (
  <Route path="/fo-reports" element={<FTTHReportsIndex />}>
    <Route index element={<Navigate to="overview" replace />} />
    <Route path="overview" element={<Overview />} />
    <Route path="utilization" element={<Utilization />} />
    <Route path="status" element={<Status />} />
    <Route path="details" element={<Details />} />
  </Route>
);

// client/src/pages/fo-reports/index.tsx
const tabs: Tab[] = [
  { name: 'Overview', href: '/fo-reports/overview' },
  { name: 'Utilization', href: '/fo-reports/utilization' },
  { name: 'Status', href: '/fo-reports/status' },
  { name: 'Details', href: '/fo-reports/details' },
];
```

4.2.2 Overview Dashboard Implementation

The Overview dashboard provides a comprehensive summary of the entire FTTH infrastructure:

```typescript
// client/src/pages/fo-reports/Overview.tsx
export default function Overview() {
  const [summary, setSummary] = useState({
    lokasi: 0,
    odc: 0,
    odp: 0,
    kabel: 0,
    kabelLength: 0,
    clientFtth: 0,
    tubes: 0,
    cores: 0,
    odpUtilization: 0,
    kabelUtilization: 0,
  });

  useEffect(() => {
    setLoading(true);
    setError(null);
    Promise.all([
      request('GET', endpoint('/api/v1/fo-lokasis')),
      request('GET', endpoint('/api/v1/fo-odcs')),
      request('GET', endpoint('/api/v1/fo-odps')),
      request('GET', endpoint('/api/v1/fo-client-ftths')),
      request('GET', endpoint('/api/v1/fo-kabel-odcs')),
      request('GET', endpoint('/api/v1/fo-kabel-tube-odcs')),
      request('GET', endpoint('/api/v1/fo-kabel-core-odcs')),
    ])
      .then(([lokasiRes, odcRes, odpRes, clientFtthRes, kabelOdcRes, tubeOdcRes, coreOdcRes]) => {
        // Calculate summary metrics
        const lokasi = lokasiRes.data.data.length;
        const odc = odcRes.data.data.length;
        const odp = odpRes.data.data.length;
        const kabel = kabelOdcRes.data.data.length;
        const kabelLength = kabelOdcRes.data.data.reduce((sum: number, k: any) =>
          sum + (k.panjang_kabel || 0), 0);
        const clientFtth = clientFtthRes.data.data.length;
        const tubes = tubeOdcRes.data.data.length;
        const cores = coreOdcRes.data.data.length;

        // Calculate utilization percentages
        const odpUtilization = odpRes.data.data.length > 0 ?
          Math.round((clientFtthRes.data.data.length / odpRes.data.data.length) * 100) : 0;
        const kabelUtilization = kabelOdcRes.data.data.length > 0 ?
          Math.round((tubeOdcRes.data.data.length / kabelOdcRes.data.data.length) * 100) : 0;

        setSummary({ lokasi, odc, odp, kabel, kabelLength, clientFtth, tubes, cores, odpUtilization, kabelUtilization });
      });
  }, []);
}
```

4.2.3 Data Visualization Components

The reporting system implements multiple chart types using Recharts library:

```typescript
// Bar Chart for ODPs per ODC
const [odpsPerOdc, setOdpsPerOdc] = useState<any[]>([]);

// Process data for bar chart
const odpsByOdc: Record<string, number> = {};
odpRes.data.data.forEach((odp: any) => {
  const odcName = odp.odc?.nama_odc || 'Unknown';
  odpsByOdc[odcName] = (odpsByOdc[odcName] || 0) + 1;
});
setOdpsPerOdc(Object.entries(odpsByOdc).map(([name, count]) => ({ name, ODPs: count })));

// Render bar chart
<ResponsiveContainer width="100%" height={300}>
  <BarChart data={odpsPerOdc}>
    <CartesianGrid strokeDasharray="3 3" />
    <XAxis dataKey="name" />
    <YAxis />
    <Tooltip />
    <Bar dataKey="ODPs" fill="#8884d8" />
  </BarChart>
</ResponsiveContainer>

// Pie Chart for ODP Status Distribution
const [odpStatusPie, setOdpStatusPie] = useState<any[]>([]);

// Process data for pie chart
const statusCounts: Record<string, number> = {};
odpRes.data.data.forEach((o: any) => {
  statusCounts[o.status] = (statusCounts[o.status] || 0) + 1;
});
setOdpStatusPie(Object.entries(statusCounts).map(([name, value]) => ({ name, value })));

// Render pie chart
<ResponsiveContainer width="100%" height={300}>
  <PieChart>
    <Pie data={odpStatusPie} dataKey="value" nameKey="name" cx="50%" cy="50%" outerRadius={80} label>
      {odpStatusPie.map((entry, idx) => (
        <Cell key={`cell-${idx}`} fill={["#8884d8", "#82ca9d", "#ffc658"][idx % 3]} />
      ))}
    </Pie>
    <Legend />
    <Tooltip />
  </PieChart>
</ResponsiveContainer>
```

4.2.4 Export Functionality

The reporting system provides both CSV and PDF export capabilities:

```typescript
// CSV Export Implementation
const handleExportCSV = () => {
  const csvRows = [
    ['Total Lokasi', summary.lokasi],
    ['Total ODC', summary.odc],
    ['Total ODP', summary.odp],
    ['Total Kabel ODC', summary.kabel],
    ['Total Kabel Length (m)', summary.kabelLength],
    ['Total Tubes', summary.tubes],
    ['Total Cores', summary.cores],
    ['Total Client FTTH', summary.clientFtth],
    ['ODP Utilization (%)', summary.odpUtilization],
    ['Kabel Utilization (%)', summary.kabelUtilization],
  ];
  const csvContent = csvRows.map(r => r.join(',')).join('\n');
  const blob = new Blob([csvContent], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'ftth-overview.csv';
  a.click();
  URL.revokeObjectURL(url);
};

// PDF Export Implementation using jsPDF and html2canvas
const handleExportPDF = async () => {
  const input = document.getElementById('ftth-overview-dashboard');
  if (!input) return;

  const canvas = await html2canvas(input);
  const imgData = canvas.toDataURL('image/png');
  const pdf = new jsPDF({ orientation: 'landscape' });
  const imgProps = pdf.getImageProperties(imgData);
  const pdfWidth = pdf.internal.pageSize.getWidth();
  const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;

  pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);
  pdf.save('ftth-overview.pdf');
};
```

4.2.5 Dashboard Layout and Responsive Design

The dashboard implements a responsive grid layout for optimal viewing across devices:

```typescript
// Summary Cards Grid
<div className="grid grid-cols-1 md:grid-cols-5 lg:grid-cols-7 gap-4 mb-8">
  <Card title="Total Lokasi" childrenClassName="flex justify-center items-center text-3xl font-bold min-h-[2.5rem]">
    {summary.lokasi}
  </Card>
  <Card title="Total ODC" childrenClassName="flex justify-center items-center text-3xl font-bold min-h-[2.5rem]">
    {summary.odc}
  </Card>
  <Card title="Total ODP" childrenClassName="flex justify-center items-center text-3xl font-bold min-h-[2.5rem]">
    {summary.odp}
  </Card>
  <Card title="Total Kabel ODC" childrenClassName="flex justify-center items-center text-3xl font-bold min-h-[2.5rem]">
    {summary.kabel}
  </Card>
  <Card title="Total Kabel Length (m)" childrenClassName="flex justify-center items-center text-3xl font-bold min-h-[2.5rem]">
    {summary.kabelLength}
  </Card>
  <Card title="Total Tubes" childrenClassName="flex justify-center items-center text-3xl font-bold min-h-[2.5rem]">
    {summary.tubes}
  </Card>
  <Card title="Total Cores" childrenClassName="flex justify-center items-center text-3xl font-bold min-h-[2.5rem]">
    {summary.cores}
  </Card>
  <Card title="Total Client FTTH" childrenClassName="flex justify-center items-center text-3xl font-bold min-h-[2.5rem]">
    {summary.clientFtth}
  </Card>
  <Card title="ODP Utilization (%)" childrenClassName="flex justify-center items-center text-2xl font-semibold min-h-[2.5rem]">
    {summary.odpUtilization}%
  </Card>
  <Card title="Kabel Utilization (%)" childrenClassName="flex justify-center items-center text-2xl font-semibold min-h-[2.5rem]">
    {summary.kabelUtilization}%
  </Card>
</div>

// Charts Grid Layout
<div className="grid grid-cols-1 md:grid-cols-3 gap-8 mb-8">
  <div className="col-span-1">
    <h2 className="text-lg font-semibold mb-2">ODPs per ODC</h2>
    {/* Bar Chart Component */}
  </div>
  <div className="col-span-1">
    <h2 className="text-lg font-semibold mb-2">Clients per ODP</h2>
    {/* Bar Chart Component */}
  </div>
  <div className="col-span-1">
    <h2 className="text-lg font-semibold mb-2">ODP Status Breakdown</h2>
    {/* Pie Chart Component */}
  </div>
</div>
```

4.2.6 Error Handling and Loading States

The reporting system implements comprehensive error handling and loading states:

```typescript
// Loading and Error State Management
const [loading, setLoading] = useState(true);
const [error, setError] = useState<string | null>(null);

useEffect(() => {
  setLoading(true);
  setError(null);

  Promise.all([
    // API calls
  ])
    .then((responses) => {
      // Process data
    })
    .catch((err) => {
      setError('Failed to load FTTH data.');
    })
    .finally(() => setLoading(false));
}, []);

// Conditional Rendering
if (loading) return <Spinner />;
if (error) return <div className="text-red-600">{error}</div>;
```

4.2.7 Performance Optimization

The reporting system implements several performance optimizations:

```typescript
// Parallel API Calls for Better Performance
Promise.all([
  request('GET', endpoint('/api/v1/fo-lokasis')),
  request('GET', endpoint('/api/v1/fo-odcs')),
  request('GET', endpoint('/api/v1/fo-odps')),
  request('GET', endpoint('/api/v1/fo-client-ftths')),
  request('GET', endpoint('/api/v1/fo-kabel-odcs')),
  request('GET', endpoint('/api/v1/fo-kabel-tube-odcs')),
  request('GET', endpoint('/api/v1/fo-kabel-core-odcs')),
])

// Efficient Data Processing
const kabelLength = kabelOdcRes.data.data.reduce((sum: number, k: any) =>
  sum + (k.panjang_kabel || 0), 0);

// Optimized Chart Rendering with ResponsiveContainer
<ResponsiveContainer width="100%" height={300}>
  {/* Chart components */}
</ResponsiveContainer>
```

4.2.8 Future Enhancements

The reporting system is designed for extensibility with planned features:

```typescript
// Planned Features Structure
const plannedFeatures = {
  clientGrowthChart: 'Line chart showing client growth over time',
  capacityPlanning: 'Predictive analytics for capacity planning',
  realTimeMonitoring: 'Real-time status monitoring dashboard',
  customDateRanges: 'Filter reports by custom date ranges',
  drillDownCapability: 'Click-through from summary to detailed views',
  automatedReports: 'Scheduled report generation and distribution',
  comparativeAnalysis: 'Compare performance across different periods',
  geographicVisualization: 'Map-based visualization of infrastructure'
};
```

The FTTH reporting system provides a comprehensive analytics platform that enables network administrators to monitor infrastructure utilization, track performance metrics, and make data-driven decisions for network optimization and expansion. The modular architecture allows for easy addition of new report types and visualization components as business requirements evolve.
